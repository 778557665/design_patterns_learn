单例模式的优点：

    1，在内存中只有一个对象，节省内存空间。

    2，避免频繁的创建销毁对象，可以提高性能。

    3，避免对共享资源的多重占用。

    4，可以全局访问。

单例模式的优点：

    1，扩展困难，由于getInstance静态函数没有办法生成子类的实例。如果要拓展，只有重写那个类。

    2，隐式使用引起类结构不清晰。

    3，导致程序内存泄露的问题。

适用场景：

        由于单例模式的以上优点，所以是编程中用的比较多的一种设计模式。以下为使用单例模式的场景：

        1，需要频繁实例化然后销毁的对象。

        2，创建对象时耗时过多或者耗资源过多，但又经常用到的对象。

        3，资源共享的情况下，避免由于资源操作时导致的性能或损耗等

        4，控制资源的情况下，方便资源之间的互相通信。

单例模式注意事项：

        只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。

        不要做断开单例类对象与类中静态引用的危险操作。

        多线程使用单例使用共享资源时，注意线程安全问题。

关于Java中单例模式的一些常见问题：

单例模式的对象长时间不用会被jvm垃圾收集器收集吗？

        除非人为地断开单例中静态引用到单例对象的联接，否则jvm垃圾收集器是不会回收单例对象的。

        jvm卸载类的判定条件如下：

            1，该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。

            2，加载该类的ClassLoader已经被回收。

            3，该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。

            只有三个条件都满足，jvm才会在垃圾收集的时候卸载类。显然，单例的类不满足条件一，因此单例类也不会被回收。

在一个jvm中会出现多个单例吗？

        在分布式系统、多个类加载器、以及序列化的的情况下，会产生多个单例，这一点是无庸置疑的。那么在同一个jvm中，会不会产生单例呢？
        使用单例提供的getInstance()方法只能得到同一个单例，除非是使用反射方式，将会得到新的单例。
        代码如下：
        Class c = Class.forName(Singleton.class.getName());
        Constructor ct = c.getDeclaredConstructor();
        ct.setAccessible(true);
        Singleton singleton = (Singleton)ct.newInstance();
        这样，每次运行都会产生新的单例对象。所以运用单例模式时，一定注意不要使用反射产生新的单例对象。

在getInstance()方法上同步有优势还是仅同步必要的块更优优势？

        因为锁定仅仅在创建实例时才有意义，然后其他时候实例仅仅是只读访问的，因此只同步必要的块的性能更优，并且是更好的选择。

        缺点：只有在第一次调用的时候，才会出现生成2个对象，才必须要求同步。而一旦singleton 不为null，系统依旧花费同步锁开销，有点得不偿失。



单例类可以被继承吗？

        根据单例实例构造的时机和方式不同，单例模式还可以分成几种。但对于这种通过私有化构造函数，静态方法提供实例的单例类而言，是不支持继承的。

        这种模式的单例实现要求每个具体的单例类自身来维护单例实例和限制多个实例的生成。但可以采用另外一种实现单例的思路：登记式单例，来使得单例对继承开放。